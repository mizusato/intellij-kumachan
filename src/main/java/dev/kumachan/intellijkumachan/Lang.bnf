// tokens and rules are generated from syntax_test.go
{
    parserClass="dev.kumachan.intellijkumachan.Parser"
    extends="com.intellij.extapi.psi.ASTWrapperPsiElement"
    psiClassPrefix=""
    psiImplClassSuffix="Impl"
    psiPackage="dev.kumachan.intellijkumachan"
    psiImplPackage="dev.kumachan.intellijkumachan.impl"
    elementTypeHolderClass="dev.kumachan.intellijkumachan.Types"
    elementTypeClass="dev.kumachan.intellijkumachan.Element"
    tokenTypeClass="dev.kumachan.intellijkumachan.Token"
    tokens=[
        DOC="regexp:///[^\n]*"
        COMMENT="regexp://[^\n]*|/\*([^\*/]|\*[^/]|[^\*]/)*\*/"
        WHITE_SPACE="regexp:[ \t\r　]+|[\n]+"
        TOKEN_TEXT="regexp:\'[^\']*\'|\"[^\"]*\""
        INT="regexp:\-?0[xX][0-9A-Fa-f]+|\-?0[oO][0-7]+|\-?0[bB][01]+|\-?\d+"
        FLOAT="regexp:\-?\d+(\.\d+)?[Ee][\+\-]?\d+|\-?\d+\.\d+"
        BYTE="regexp:\\x[0-9A-Fa-f][0-9A-Fa-f]"
        CHAR="regexp:`.`|\\u[0-9A-Fa-f]+|\\[a-z]"
        SYM4000="regexp:\("
        SYM4100="regexp:\)"
        SYM9100="regexp:\["
        SYM9300="regexp:\]"
        SYM12300="regexp:\{"
        SYM12500="regexp:\}"
        SYM460046004600="regexp:\.\.\."
        SYM46004600="regexp:\.\."
        SYM4600="regexp:\."
        SYM4400="regexp:,"
        SYM58005800="regexp:::"
        SYM5800="regexp::"
        SYM5900="regexp:;"
        SYM6400="regexp:@"
        SYM3800="regexp:\&"
        SYM12400="regexp:\|"
        SYM9200="regexp:\\"
        IF="regexp:if"
        ELSE="regexp:else"
        WHEN="regexp:when"
        LET="regexp:let"
        NEW="regexp:new"
        SYM61006200="regexp:=>"
        SYM6100="regexp:="
        TOKEN_NAME="regexp:[^0-9\{\}\[\]\(\)\.,:;@\&\|\\\'\"` \t\r　\n][^\{\}\[\]\(\)\.,:;@\&\|\\\'\"` \t\r　\n]*"
    ]
}

root ::= ns stmt*
ns ::= namespace node_name? SYM58005800
node_name ::= TOKEN_NAME
stmt ::= decl_entry | decl_type | decl_func | decl_const | decl_method
decl_entry ::= entry block
decl_type ::= docs? type node_name type_params? impl? type_def
type_params ::= SYM9100 [ node_name { SYM4400 node_name }* ] SYM9300
docs ::= node_doc+
node_doc ::= DOC
impl ::= SYM4000 [ ref_base { SYM4400 ref_base }* ] SYM4100
ref_base ::= ns_prefix? node_name
ns_prefix ::= node_name SYM58005800
type_def ::= native_type_def | node_record | node_interface | node_union | node_enum
native_type_def ::= native
node_record ::= record record_def
record_def ::= SYM12300 [ field { SYM4400 field }* ] SYM12500
field ::= docs? node_name node_type field_default?
field_default ::= default SYM4000 expr SYM4100
node_interface ::= interface SYM12300 [ node_method { SYM4400 node_method }* ] SYM12500
node_method ::= docs? node_name node_type
node_union ::= union SYM12300 node_type { SYM4400 node_type }* SYM12500
node_enum ::= enum SYM12300 enum_item { SYM4400 enum_item }* SYM12500
enum_item ::= docs? node_name
decl_func ::= docs? node_function node_variadic? node_name sig body
node_function ::= function | operator
node_variadic ::= variadic
sig ::= type_params? inputs implicit? output
inputs ::= record_def
implicit ::= inputs
output ::= node_type
body ::= native_body | block
native_body ::= native SYM4000 node_text SYM4100
decl_const ::= docs? const node_name node_type body
decl_method ::= docs? method receiver SYM4600 node_name node_type body
receiver ::= node_name
node_type ::= ref
ref ::= ref_base type_args?
type_args ::= SYM9100 [ node_type { SYM4400 node_type }* ] SYM9300
expr ::= cast* term pipe*
cast ::= SYM4000 SYM9100 node_type SYM9300 SYM4100
pipe ::= pipe_call | pipe_infix | pipe_cast | pipe_get | pipe_interior
pipe_call ::= call_ordered | call_unordered
call_ordered ::= SYM4000 [ expr { SYM4400 expr }* ] SYM4100
call_unordered ::= SYM12300 [ arg_mapping { SYM4400 arg_mapping }* ] SYM12500
arg_mapping ::= node_name arg_mapping_to?
arg_mapping_to ::= SYM5800 expr
pipe_infix ::= SYM12400 ref pipe_call
pipe_cast ::= SYM4600 cast
pipe_get ::= SYM4600 node_name
pipe_interior ::= SYM4600 SYM4000 ref_base SYM4100
term ::= infix_term | lambda | node_if | node_when | block | ref_term | node_int | node_float | node_char | bytes | node_string
infix_term ::= SYM4000 infix_left node_operator infix_right SYM4100
infix_left ::= expr
node_operator ::= ref
infix_right ::= expr
lambda ::= SYM12300 pattern? lambda_self? SYM61006200 expr SYM12500
lambda_self ::= SYM3800 node_name
pattern ::= pattern_single | pattern_multiple
pattern_single ::= node_name
pattern_multiple ::= SYM4000 node_name { SYM4400 node_name }* SYM4100
node_if ::= IF SYM4000 cond { SYM4400 cond }* SYM4100 if_yes elif* ELSE if_no
cond ::= cond_pattern? expr
cond_pattern ::= LET pattern SYM6100
if_yes ::= block
if_no ::= block
elif ::= IF SYM4000 cond { SYM4400 cond }* SYM4100 block
node_when ::= WHEN SYM4000 expr SYM4100 SYM12300 case { SYM4400 case }* SYM12500
case ::= node_name { SYM12400 node_name }* pattern? SYM61006200 expr
block ::= SYM12300 binding* expr SYM12500
binding ::= binding_plain | binding_cps
binding_plain ::= LET pattern SYM6100 expr SYM4400
binding_cps ::= SYM6400 ref cps_pattern? expr SYM4400
cps_pattern ::= pattern SYM6100
ref_term ::= node_new? ref
node_new ::= NEW new_tag?
new_tag ::= SYM5800 node_name
node_int ::= INT
node_float ::= FLOAT
node_char ::= CHAR
bytes ::= node_byte+
node_byte ::= BYTE
node_string ::= node_text string_part*
node_text ::= TOKEN_TEXT
string_part ::= SYM46004600 string_part_content
string_part_content ::= node_text | node_char


