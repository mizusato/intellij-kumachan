// tokens and rules are generated from syntax_test.go
{
    parserClass="dev.kumachan.intellijkumachan.Parser"
    extends="com.intellij.extapi.psi.ASTWrapperPsiElement"
    psiClassPrefix=""
    psiImplClassSuffix="Impl"
    psiPackage="dev.kumachan.intellijkumachan"
    psiImplPackage="dev.kumachan.intellijkumachan.impl"
    elementTypeHolderClass="dev.kumachan.intellijkumachan.Types"
    elementTypeClass="dev.kumachan.intellijkumachan.Element"
    tokenTypeClass="dev.kumachan.intellijkumachan.Token"
    tokens=[
        DOC="regexp:///[^\n]*"
        COMMENT="regexp://[^\n]*|/\*([^\*/]|\*[^/]|[^\*]/)*\*/"
        WHITE_SPACE="regexp:[ \t\r　]+|[\n]+"
        TOKEN_TEXT="regexp:\'[^\']*\'|\"[^\"]*\""
        INT="regexp:\-?0[xX][0-9A-Fa-f]+|\-?0[oO][0-7]+|\-?0[bB][01]+|\-?\d+"
        FLOAT="regexp:\-?\d+(\.\d+)?[Ee][\+\-]?\d+|\-?\d+\.\d+"
        BYTE="regexp:\\x[0-9A-Fa-f][0-9A-Fa-f]"
        CHAR="regexp:`.`|\\u[0-9A-Fa-f]+|\\[a-z]"
        SYM0="regexp:\("
        SYM1="regexp:\)"
        SYM2="regexp:\["
        SYM3="regexp:\]"
        SYM4="regexp:\{"
        SYM5="regexp:\}"
        SYM6="regexp:\.\.\."
        SYM7="regexp:\.\."
        SYM8="regexp:\."
        SYM9="regexp:,"
        SYM10="regexp:::"
        SYM11="regexp::"
        SYM12="regexp:;"
        SYM13="regexp:@"
        SYM14="regexp:\&"
        SYM15="regexp:\|"
        SYM16="regexp:\\"
        IF="regexp:if"
        ELSE="regexp:else"
        WHEN="regexp:when"
        LET="regexp:let"
        NEW="regexp:new"
        SYM17="regexp:=>"
        SYM18="regexp:="
        TOKEN_NAME="regexp:[^0-9\{\}\[\]\(\)\.,:;@\&\|\\\'\"` \t\r　\n][^\{\}\[\]\(\)\.,:;@\&\|\\\'\"` \t\r　\n]*"
    ]
}

root ::= ns stmt*
ns ::= namespace node_name? SYM10
node_name ::= TOKEN_NAME
stmt ::= decl_entry | decl_type | decl_func | decl_const | decl_method
decl_entry ::= entry block
decl_type ::= docs? type node_name type_params? impl? type_def
type_params ::= SYM2 [ node_name { SYM9 node_name }* ] SYM3
docs ::= node_doc+
node_doc ::= DOC
impl ::= SYM0 [ ref_base { SYM9 ref_base }* ] SYM1
ref_base ::= ns_prefix? node_name
ns_prefix ::= node_name SYM10
type_def ::= native_type_def | node_record | node_interface | node_union | node_enum
native_type_def ::= native
node_record ::= record record_def
record_def ::= SYM4 [ field { SYM9 field }* ] SYM5
field ::= docs? node_name node_type field_default?
field_default ::= default SYM0 expr SYM1
node_interface ::= interface SYM4 [ node_method { SYM9 node_method }* ] SYM5
node_method ::= docs? node_name node_type
node_union ::= union SYM4 node_type { SYM9 node_type }* SYM5
node_enum ::= enum SYM4 enum_item { SYM9 enum_item }* SYM5
enum_item ::= docs? node_name
decl_func ::= docs? node_function node_variadic? node_name sig body
node_function ::= function | operator
node_variadic ::= variadic
sig ::= type_params? inputs implicit? output
inputs ::= record_def
implicit ::= inputs
output ::= node_type
body ::= native_body | block
native_body ::= native SYM0 node_text SYM1
decl_const ::= docs? const node_name node_type body
decl_method ::= docs? method receiver SYM8 node_name node_type body
receiver ::= node_name
node_type ::= ref
ref ::= ref_base type_args?
type_args ::= SYM2 [ node_type { SYM9 node_type }* ] SYM3
expr ::= cast* term pipe*
cast ::= SYM0 SYM2 node_type SYM3 SYM1
pipe ::= pipe_call | pipe_infix | pipe_cast | pipe_get | pipe_interior
pipe_call ::= call_ordered | call_unordered
call_ordered ::= SYM0 [ expr { SYM9 expr }* ] SYM1
call_unordered ::= SYM4 [ arg_mapping { SYM9 arg_mapping }* ] SYM5
arg_mapping ::= node_name arg_mapping_to?
arg_mapping_to ::= SYM11 expr
pipe_infix ::= SYM15 ref pipe_call
pipe_cast ::= SYM8 cast
pipe_get ::= SYM8 node_name
pipe_interior ::= SYM8 SYM0 ref_base SYM1
term ::= infix_term | lambda | node_if | node_when | block | ref_term | node_int | node_float | node_char | bytes | node_string
infix_term ::= SYM0 infix_left node_operator infix_right SYM1
infix_left ::= expr
node_operator ::= ref
infix_right ::= expr
lambda ::= SYM4 pattern? lambda_self? SYM17 expr SYM5
lambda_self ::= SYM14 node_name
pattern ::= pattern_single | pattern_multiple
pattern_single ::= node_name
pattern_multiple ::= SYM0 node_name { SYM9 node_name }* SYM1
node_if ::= IF SYM0 cond { SYM9 cond }* SYM1 if_yes elif* ELSE if_no
cond ::= cond_pattern? expr
cond_pattern ::= LET pattern SYM18
if_yes ::= block
if_no ::= block
elif ::= IF SYM0 cond { SYM9 cond }* SYM1 block
node_when ::= WHEN SYM0 expr SYM1 SYM4 case { SYM9 case }* SYM5
case ::= node_name { SYM15 node_name }* pattern? SYM17 expr
block ::= SYM4 binding* expr SYM5
binding ::= binding_plain | binding_cps
binding_plain ::= LET pattern SYM18 expr SYM9
binding_cps ::= SYM13 ref cps_pattern? expr SYM9
cps_pattern ::= pattern SYM18
ref_term ::= node_new? ref
node_new ::= NEW
node_int ::= INT
node_float ::= FLOAT
node_char ::= CHAR
bytes ::= node_byte+
node_byte ::= BYTE
node_string ::= node_text string_part*
node_text ::= TOKEN_TEXT
string_part ::= SYM7 string_part_content
string_part_content ::= node_text | node_char


